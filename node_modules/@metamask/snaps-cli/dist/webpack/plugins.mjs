var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SnapsStatsPlugin_instances, _SnapsStatsPlugin_spinner, _SnapsStatsPlugin_getStatsErrorMessage, _SnapsWatchPlugin_instances, _SnapsWatchPlugin_spinner, _SnapsWatchPlugin_safeEvaluate, _SnapsBuiltInResolver_source, _SnapsBuiltInResolver_spinner, _SnapsBundleWarningsPlugin_instances, _SnapsBundleWarningsPlugin_checkBuiltIns, _SnapsBundleWarningsPlugin_isProvidePlugin, _SnapsBundleWarningsPlugin_checkBuffer;
import { assert, hasProperty, isObject } from "@metamask/utils";
import $chalk from "chalk";
const { bold, dim, red, yellow } = $chalk;
import { isBuiltin } from "module";
import $webpack from "webpack";
const { WebpackError } = $webpack;
import { evaluate } from "../commands/eval/index.mjs";
import { error, getErrorMessage, info, warn } from "../utils/index.mjs";
import { formatText, pluralize } from "./utils.mjs";
/**
 * A plugin that logs the stats after compilation. This is useful for logging
 * the number of files compiled, and the time taken to compile them.
 */
export class SnapsStatsPlugin {
    constructor(options = {
        verbose: false,
    }, spinner) {
        _SnapsStatsPlugin_instances.add(this);
        /**
         * The spinner to use for logging.
         */
        _SnapsStatsPlugin_spinner.set(this, void 0);
        this.options = options;
        __classPrivateFieldSet(this, _SnapsStatsPlugin_spinner, spinner, "f");
    }
    /**
     * Apply the plugin to the Webpack compiler.
     *
     * @param compiler - The Webpack compiler.
     */
    apply(compiler) {
        compiler.hooks.afterDone.tap(this.constructor.name, (stats) => {
            if (!stats) {
                return;
            }
            const { modules, time, errors, warnings } = stats.toJson();
            assert(modules, 'Modules must be defined in stats.');
            assert(time, 'Time must be defined in stats.');
            if (errors?.length) {
                const formattedErrors = errors
                    .map((statsError) => __classPrivateFieldGet(this, _SnapsStatsPlugin_instances, "m", _SnapsStatsPlugin_getStatsErrorMessage).call(this, statsError))
                    .join('\n\n');
                error(`Compiled ${modules.length} ${pluralize(modules.length, 'file')} in ${time}ms with ${errors.length} ${pluralize(errors.length, 'error')}.\n\n${formattedErrors}\n`, __classPrivateFieldGet(this, _SnapsStatsPlugin_spinner, "f"));
                __classPrivateFieldGet(this, _SnapsStatsPlugin_spinner, "f")?.stop();
                process.exitCode = 1;
                return;
            }
            if (warnings?.length) {
                const formattedWarnings = warnings
                    .map((statsWarning) => __classPrivateFieldGet(this, _SnapsStatsPlugin_instances, "m", _SnapsStatsPlugin_getStatsErrorMessage).call(this, statsWarning, yellow))
                    .join('\n\n');
                warn(`Compiled ${modules.length} ${pluralize(modules.length, 'file')} in ${time}ms with ${warnings.length} ${pluralize(warnings.length, 'warning')}.\n\n${formattedWarnings}\n`, __classPrivateFieldGet(this, _SnapsStatsPlugin_spinner, "f"));
            }
            else {
                info(`Compiled ${modules.length} ${pluralize(modules.length, 'file')} in ${time}ms.`, __classPrivateFieldGet(this, _SnapsStatsPlugin_spinner, "f"));
            }
            if (compiler.watchMode) {
                // The spinner may be restarted by the watch plugin, outside of the
                // `executeSteps` flow, so we stop it here just in case.
                __classPrivateFieldGet(this, _SnapsStatsPlugin_spinner, "f")?.succeed('Done!');
            }
        });
    }
}
_SnapsStatsPlugin_spinner = new WeakMap(), _SnapsStatsPlugin_instances = new WeakSet(), _SnapsStatsPlugin_getStatsErrorMessage = function _SnapsStatsPlugin_getStatsErrorMessage(statsError, color = red) {
    const baseMessage = this.options.verbose
        ? getErrorMessage(statsError)
        : statsError.message;
    const [first, ...rest] = baseMessage.split('\n');
    return [
        color(formatText(`• ${first}`, 4, 2)),
        ...rest.map((message) => formatText(color(message), 4)),
        statsError.details && `\n${formatText(dim(statsError.details), 6)}`,
    ]
        .filter(Boolean)
        .join('\n');
};
/**
 * A plugin that adds extra files to watch. This is useful for watching files
 * that are not imported by the entry point, such as the `snap.manifest.json`
 * file.
 */
export class SnapsWatchPlugin {
    constructor(options, spinner) {
        _SnapsWatchPlugin_instances.add(this);
        /**
         * The spinner to use for logging.
         */
        _SnapsWatchPlugin_spinner.set(this, void 0);
        this.options = options;
        __classPrivateFieldSet(this, _SnapsWatchPlugin_spinner, spinner, "f");
    }
    /**
     * Apply the plugin to the Webpack compiler.
     *
     * @param compiler - The Webpack compiler.
     */
    apply(compiler) {
        compiler.hooks.invalid.tap(this.constructor.name, (file) => {
            __classPrivateFieldGet(this, _SnapsWatchPlugin_spinner, "f")?.start();
            info(`Changes detected in ${yellow(file)}, recompiling.`, __classPrivateFieldGet(this, _SnapsWatchPlugin_spinner, "f"));
        });
        compiler.hooks.afterEmit.tapPromise(this.constructor.name, async ({ fileDependencies }) => {
            this.options.files?.forEach(fileDependencies.add.bind(fileDependencies));
            if (this.options.bundle && this.options.evaluate) {
                await __classPrivateFieldGet(this, _SnapsWatchPlugin_instances, "m", _SnapsWatchPlugin_safeEvaluate).call(this, this.options.bundle);
            }
        });
    }
}
_SnapsWatchPlugin_spinner = new WeakMap(), _SnapsWatchPlugin_instances = new WeakSet(), _SnapsWatchPlugin_safeEvaluate = 
/**
 * Safely evaluate the bundle at the given path. If an error occurs, it will
 * be logged to the console, rather than throwing an error.
 *
 * This function should never throw an error.
 *
 * @param bundlePath - The path to the bundle.
 */
async function _SnapsWatchPlugin_safeEvaluate(bundlePath) {
    try {
        await evaluate(bundlePath);
        info(`Snap bundle evaluated successfully.`, __classPrivateFieldGet(this, _SnapsWatchPlugin_spinner, "f"));
    }
    catch (evaluateError) {
        error(evaluateError.message, __classPrivateFieldGet(this, _SnapsWatchPlugin_spinner, "f"));
    }
};
/**
 * A plugin that logs a message when a built-in module is not resolved. The
 * MetaMask Snaps CLI does not support built-in modules by default, and this
 * plugin is used to warn the user when they try to import a built-in module,
 * when no fallback is configured.
 */
export class SnapsBuiltInResolver {
    constructor(options = {
        ignore: [],
    }, spinner) {
        /**
         * The built-in modules that have been imported, but not resolved.
         */
        this.unresolvedModules = new Set();
        /**
         * The name of the resolver hook to tap into.
         */
        _SnapsBuiltInResolver_source.set(this, 'described-resolve');
        /**
         * The spinner to use for logging.
         */
        _SnapsBuiltInResolver_spinner.set(this, void 0);
        this.options = options;
        __classPrivateFieldSet(this, _SnapsBuiltInResolver_spinner, spinner, "f");
    }
    /**
     * Apply the plugin to the Webpack resolver.
     *
     * @param resolver - The Webpack resolver.
     */
    apply(resolver) {
        resolver
            .getHook(__classPrivateFieldGet(this, _SnapsBuiltInResolver_source, "f"))
            .tapAsync(this.constructor.name, ({ module: isModule, request }, _, callback) => {
            if (!isModule || !request) {
                return callback();
            }
            const baseRequest = request.split('/')[0];
            if (isBuiltin(baseRequest) &&
                !this.options.ignore?.includes(baseRequest)) {
                const fallback = resolver.options.fallback.find(({ name }) => name === baseRequest);
                if (fallback && !fallback.alias) {
                    this.unresolvedModules.add(baseRequest);
                }
            }
            return callback();
        });
    }
}
_SnapsBuiltInResolver_source = new WeakMap(), _SnapsBuiltInResolver_spinner = new WeakMap();
/**
 * A plugin that logs a message when:
 *
 * - A built-in module is not resolved. The MetaMask Snaps CLI does not support
 * built-in modules by default, and this plugin is used to warn the user when
 * they try to import a built-in module, when no fallback is configured.
 * - A snap uses the `Buffer` global. The MetaMask Snaps CLI does not support
 * the `Buffer` global by default, and this plugin is used to warn the user when
 * they try to use the `Buffer` global.
 *
 * We use both a resolver and a plugin, because the resolver is used to detect
 * when a built-in module is imported, and the plugin is used to log a single
 * message when the compilation is complete. We can't do everything in a single
 * plugin, because the resolver doesn't have access to the compilation, and the
 * plugin doesn't have access to the resolver.
 */
export class SnapsBundleWarningsPlugin {
    constructor(options = {
        buffer: true,
        builtIns: true,
    }) {
        _SnapsBundleWarningsPlugin_instances.add(this);
        this.options = options;
    }
    /**
     * Apply the plugin to the Webpack compiler.
     *
     * @param compiler - The Webpack compiler.
     */
    apply(compiler) {
        if (this.options.builtIns) {
            __classPrivateFieldGet(this, _SnapsBundleWarningsPlugin_instances, "m", _SnapsBundleWarningsPlugin_checkBuiltIns).call(this, compiler);
        }
        if (this.options.buffer) {
            __classPrivateFieldGet(this, _SnapsBundleWarningsPlugin_instances, "m", _SnapsBundleWarningsPlugin_checkBuffer).call(this, compiler);
        }
    }
}
_SnapsBundleWarningsPlugin_instances = new WeakSet(), _SnapsBundleWarningsPlugin_checkBuiltIns = function _SnapsBundleWarningsPlugin_checkBuiltIns(compiler) {
    compiler.hooks.afterCompile.tap(this.constructor.name, (compilation) => {
        if (!this.options.builtInResolver) {
            return;
        }
        const { unresolvedModules } = this.options.builtInResolver;
        if (unresolvedModules.size === 0) {
            return;
        }
        const formattedModules = new Array(...unresolvedModules)
            .map((name) => `• ${name}`)
            .join('\n');
        const webpackError = new WebpackError(`The snap attempted to use one or more Node.js builtins, but no browser fallback has been provided. The MetaMask Snaps CLI does not support Node.js builtins by default. If you want to use this module, you must set ${bold('`polyfills`')} to ${bold('`true`')} or an object with the builtins to polyfill as the key and ${bold('`true`')} as the value. To disable this warning, set ${bold('`stats.builtIns`')} to ${bold('`false`')} in your snap config file, or add the module to the ${bold('`stats.builtIns.ignore`')} array.`);
        webpackError.details = formattedModules;
        compilation.warnings.push(webpackError);
    });
}, _SnapsBundleWarningsPlugin_isProvidePlugin = function _SnapsBundleWarningsPlugin_isProvidePlugin(instance) {
    return (isObject(instance) &&
        instance.constructor.name === 'ProvidePlugin' &&
        hasProperty(instance, 'definitions'));
}, _SnapsBundleWarningsPlugin_checkBuffer = function _SnapsBundleWarningsPlugin_checkBuffer(compiler) {
    const plugin = compiler.options.plugins?.find((instance) => __classPrivateFieldGet(this, _SnapsBundleWarningsPlugin_instances, "m", _SnapsBundleWarningsPlugin_isProvidePlugin).call(this, instance));
    // If the `ProvidePlugin` is configured to provide `Buffer`, then we don't
    // need to warn the user.
    if (plugin) {
        const { definitions } = plugin;
        if (definitions.Buffer) {
            return;
        }
    }
    compiler.hooks.compilation.tap(this.constructor.name, (compilation) => {
        compilation.hooks.afterProcessAssets.tap(this.constructor.name, (assets) => {
            // Check if assets use `Buffer`.
            const bufferAssets = Object.entries(assets)
                .filter(([name]) => name.endsWith('.js'))
                .filter(([, asset]) => asset.source().includes('Buffer'));
            if (bufferAssets.length === 0) {
                return;
            }
            compilation.warnings.push(new WebpackError(`The snap attempted to use the Node.js Buffer global, which is not supported in the MetaMask Snaps CLI by default. To use the Buffer global, you must polyfill Buffer by setting ${bold('`buffer`')} to ${bold('`true`')} in the ${bold('`polyfills`')} config object in your snap config. To disable this warning, set ${bold('`stats.buffer`')} to ${bold('`false`')} in your snap config file.`));
        });
    });
};
//# sourceMappingURL=plugins.mjs.map